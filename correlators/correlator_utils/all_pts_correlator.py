import jax.numpy as jnp
from jax import vmap
from jax import random
from math import factorial


def partition(collection):
	'''
	Helper function to generate set partitions.

		Input:
		- collection: list
			Collection of items to be broken up into partitions

		Output: generator_object
			- Yields first item in collection and smaller subset 
	'''
	collection = list(collection)
	if len(collection) == 1:
		yield [collection]
		return

	first = collection[0]
	for smaller in partition(collection[1:]):
		# insert `first` in each of the subpartition's subsets
		for n, subset in enumerate(smaller):
			yield smaller[:n] + [[first] + subset]  + smaller[n+1:]
			# put `first` in its own subset 
			yield [[first]] + smaller
			
def perform_contractions(partitions):
	''' Perform Wick-style 'contractions' on the dataset. 
	Input:
	- partitions: list
		All partitions in a given set. Generated by partitions
	- data: array-like
		Grid of all pixel vales. Grid must be invariant under 
		broadcast and should represent a single time-step in the diffusion
		process

	Output:
	- expansion: float
		Value of n-point cumulant by performing moment-cumulant expansion
	'''
	expansion = 0
	# partition will be like [[1, 2], [3]]
	for partition in partitions:
		term = 1
		for block in partition:
			length = len(block)
			assert length > 0
			# i.e. E(x^l y^m). Each i corresp. to block element
			# First need the product
			contraction = sum(block)/length
			term = term * contraction
		length = len(partition)
		sign = (-1)**(length - 1)
		expansion += term * sign * factorial(length-1)
	return expansion

# Each generator is disposable. Python!
def wrapper(correlator):
	return perform_contractions(list(partition(correlator)))

# Initialise with some random MNIST lengthed data

key = random.PRNGKey(0)
# x = random.normal(key, (28**2,))

x = jnp.array([1,2,3,4])
# print(x.shape)
# l = len(x)

# Consiser an n=2 length correlator
n = 2

# Meshgrid is a tuple of length n
meshgrid = jnp.meshgrid(*[x]*n)

#####################################
# TEST SEQUENCE
#####################################
# correlators = jnp.dstack((meshgrid)).reshape(-1, n)
# print(correlators.shape)

# print(jnp.array(vmap(wrapper)(correlators)).shape)
# print('done!')

# for i in range(correlators.shape[0]):
# 	print(wrapper(correlators[i]))

# print(jnp.dstack(meshgrid))
# print(zz)
# print(yy)
# print(zz)
# print(xx.shape)
