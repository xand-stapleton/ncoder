# import numpy as np
import jax.numpy as jnp
from math import factorial
from jax import vmap
from .helper_functions import partition
import numpy as np


def perform_contractions(partitions):
    ''' Perform Wick-style 'contractions' on the dataset.
    Input:
    - partitions: list
        All partitions in a given set. Generated by partitions
    - data: array-like
        Grid of all pixel vales. Grid must be invariant under
        broadcast and should represent a single time-step in the diffusion
        process

    Output:
    - expansion: float
        Value of n-point cumulant by performing moment-cumulant expansion
    '''
    expansion = 0
    # partition will be like [[1, 2], [3]]
    for partition in partitions:
        term = 1
        for block in partition:
            length = len(block)
            assert length > 0
            # i.e. E(x^l y^m). Each i corresp. to block element
            # First need the product
            contraction = sum(block)/length
            term = term * contraction
        length = len(partition)
        sign = (-1)**(length - 1)
        expansion += term * sign * factorial(length-1)
    return expansion


def block(image, rows, cols):
    '''
    Take an image of dimension (?channels x) orig_rows x orig_cols and split into
    blocks of dimension rows x cols. This should work with both Jax and NumPy.
    The method expects torch tensors to be flattened and converted to Jax/Numpy
    arrays before passing in
    '''
    # Case 1: We have 3 cases here, the image is 2-d and has no channel info
    # (single colour). Make the tensor 3d by adding a unit column
    # Case 2: We have 3 dimensions. There is channel information. Do nothing
    # Case 3: There is a dimension mismatch (dimension is not 2 or 3)

    if image.ndim == 2:
        # image = image.unsqueeze(0)
        image = jnp.expand_dims(image, axis=0)
    elif image.ndim != 3:
        raise Exception('Dimension Error. Image is neither 2D or 3D.')

    channels, orig_rows, orig_cols = image.shape

    assert orig_rows % rows == 0, (f'Image row size is not wholly divisible'
                                    'by block row size {orig_rows}%{rows}!=0')
    assert orig_cols % cols == 0, (f'Image column size is not wholly divisible'
                                    'by block column size'
				    '{orig_cols}%{rows}!=0')

    # This returns a channels x orig_rows//rows x orig_cols//cols 
    return (image.reshape(channels, orig_rows//rows, rows, -1, cols)
            .swapaxes(2,3)
            .reshape(channels, -1, rows, cols))


def wrapper(correlator):
    return perform_contractions(list(partition(correlator)))


def block_correlator(block, n):
    '''Calculates the correlator of a 2-d blocked matrix'''
    # flattened_block = block.flatten()
    meshgrid = jnp.meshgrid(*[block]*n)
    correlators = jnp.dstack((meshgrid)).reshape(-1, n)
    # return correlators
    return jnp.array(vmap(wrapper)(correlators))


def channels(image):
    if image.ndim == 2:
        return 1
    elif image.ndim != 3:
        raise Exception('Invalid image shape or dimensionality')
    else:
        return image.shape[0]

def block_and_average(unblocked_image, block_rows, block_columns):
    # We have to use numpy here because Torch hates jax
    # If there's one (implicit) channel, make it explicit
    if unblocked_image.ndim == 2:
        unblocked_image = np.expand_dims(unblocked_image, axis=0)
    # Else if there's something other than channel info and pixel info,
    # raise an exception
    elif unblocked_image.ndim != 3:
        raise Exception('Invalid image dimensionality')
    chan, orig_rows, orig_cols = unblocked_image.shape
    
    # Block the image. Notice tbat bhf.block preserves rows for traceability,
    # so we take care of that with a reshape
    blocked_image = block(unblocked_image, block_rows, block_columns).reshape(-1, block_rows, block_columns)
    # Average over each block to generate a grainier image
    vector_block_average = vmap(block_average)
    return np.asarray(vector_block_average(blocked_image).reshape(chan,
                                                        orig_rows//block_rows,
                                                        orig_cols//block_columns))

def block_average(block):
    return jnp.mean(block)
